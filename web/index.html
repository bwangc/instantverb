<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instantdict</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .search-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 25vh;
            transition: margin-top 0.3s ease;
            width: 100%;
            max-width: 600px;
        }

        .search-container.has-results {
            margin-top: 40px;
        }

        h1 {
            font-weight: 300;
            font-size: 3.5rem;
            margin-bottom: 30px;
            color: #a5b4fc;
            letter-spacing: -1px;
        }

        .input-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
        }

        #search {
            font-size: 1.1rem;
            padding: 14px 24px;
            border: 1px solid #3a3a5e;
            border-radius: 24px;
            background: #252542;
            color: #eee;
            width: 100%;
            outline: none;
            transition: all 0.2s;
        }

        #search:hover {
            border-color: #5a5a7e;
        }

        #search:focus {
            border-color: #a5b4fc;
            background: #2a2a4a;
        }

        #search::placeholder { color: #666; }

        .suggestions {
            width: 100%;
            max-width: 500px;
            margin-top: 12px;
            display: none;
        }

        .suggestions.visible { display: block; }

        .suggestion {
            padding: 10px 24px;
            cursor: pointer;
            background: #252542;
            border-radius: 8px;
            margin-bottom: 4px;
        }

        .suggestion:hover, .suggestion.selected {
            background: #3a3a5e;
        }

        .suggestion .pos {
            margin-left: 8px;
            font-size: 0.85rem;
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            margin-top: 12px;
            height: 20px;
        }

        .status.ready { color: #4ade80; }
        .status.loading { color: #a5b4fc; }

        #result {
            margin-top: 40px;
            width: 100%;
            max-width: 700px;
        }

        .entry {
            background: #252542;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .entry-header {
            display: flex;
            align-items: baseline;
            gap: 12px;
            margin-bottom: 12px;
        }

        .word {
            font-size: 1.5rem;
            color: #a5b4fc;
        }

        .pos {
            font-size: 0.9rem;
            color: #888;
            font-style: italic;
        }

        .ipa {
            font-size: 0.9rem;
            color: #888;
        }

        .sense {
            margin: 12px 0;
            padding-left: 16px;
            border-left: 2px solid #3a3a5e;
        }

        .gloss {
            color: #eee;
            margin-bottom: 6px;
        }

        .example {
            font-size: 0.9rem;
            color: #aaa;
            margin: 4px 0;
        }

        .example-fr { font-style: italic; }
        .example-en { color: #888; }

        .audio-btn {
            background: none;
            border: 1px solid #3a3a5e;
            color: #a5b4fc;
            padding: 4px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .audio-btn:hover { background: #3a3a5e; }

        .conjugate-btn {
            background: none;
            border: 1px solid #3a3a5e;
            color: #a5b4fc;
            padding: 4px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .conjugate-btn:hover { background: #3a3a5e; }

        .conjugation-tables {
            margin: 16px 0;
            overflow-x: auto;
            display: inline-flex;
            flex-direction: column;
        }

        .conjugation-tables table {
            border-collapse: collapse;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .conjugation-tables th, .conjugation-tables td {
            padding: 8px 12px;
            text-align: left;
        }

        .conjugation-tables th {
            color: #a5b4fc;
            border-bottom: 1px solid #a5b4fc;
        }

        .conjugation-tables .inf-cell {
            font-style: italic;
            border-bottom: none;
        }

        .conjugation-tables tr.zebra {
            background: rgba(255,255,255,0.03);
        }

        .conjugation-tables .person-label {
            color: #a5b4fc;
        }

        .conjugation-tables .irregular {
            color: #a5b4fc;
        }

        .etymology {
            font-size: 0.85rem;
            color: #888;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #3a3a5e;
        }

        .etymology-text {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .etymology-text.collapsed {
            max-height: 150px;
        }

        .etymology-text.expanded {
            max-height: 2000px;
        }

        .etymology-text.hidden {
            max-height: 0;
            opacity: 0;
        }

        .etymology-text p {
            margin: 0 0 8px 0;
        }

        .etymology-text p:last-child {
            margin-bottom: 0;
        }

        .etymology-toggle {
            color: #666;
            cursor: pointer;
            font-size: 0.7rem;
            margin-left: 8px;
            transition: color 0.15s;
        }

        .etymology-toggle:hover {
            color: #a5b4fc;
        }

        .no-results {
            color: #888;
            text-align: center;
            padding: 40px;
        }

        .conjugation-note {
            color: #a5b4fc;
            font-size: 0.9rem;
            margin-bottom: 16px;
            padding: 8px 16px;
            background: rgba(165, 180, 252, 0.1);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="search-container" id="container">
        <h1>Instantdict</h1>
        <div class="input-wrapper">
            <input type="text" id="search" placeholder="Search French words..." autocomplete="off" autofocus>
        </div>
        <div class="status loading" id="status">Loading dictionary...</div>
        <div class="suggestions" id="suggestions"></div>
    </div>

    <div id="result"></div>

    <script>
        let dict = null;
        let formIndex = null;  // conjugated form -> infinitive(s)
        let formAudio = null;  // conjugated form -> audio URL
        let wordList = [];  // Ordered list for autocomplete
        let isReady = false;
        let selectedIdx = -1;

        const search = document.getElementById('search');
        const result = document.getElementById('result');
        const status = document.getElementById('status');
        const container = document.getElementById('container');
        const suggestions = document.getElementById('suggestions');

        // Load dictionary in background
        async function loadDictionary() {
            try {
                // Load all in parallel
                const [dictRes, formsRes, audioRes] = await Promise.all([
                    fetch('data/fr-10k.json'),
                    fetch('data/fr-10k-forms.json'),
                    fetch('data/fr-form-audio.json')
                ]);
                dict = await dictRes.json();
                formIndex = (await formsRes.json()).forms;
                formAudio = await audioRes.json();
                wordList = Object.keys(dict.words);  // Preserves frequency order
                isReady = true;
                status.textContent = '';
                status.className = 'status';

                // If user already typed something, search now
                if (search.value.trim()) {
                    updateSuggestions(search.value.trim().toLowerCase());
                }
            } catch (e) {
                status.textContent = 'Failed to load dictionary';
                status.className = 'status';
            }
        }

        function renderEntry(entry) {
            const entryId = 'entry-' + Math.random().toString(36).substr(2, 9);
            let html = `<div class="entry" id="${entryId}">`;
            html += `<div class="entry-header">`;
            html += `<span class="word">${entry.word}</span>`;
            html += `<span class="pos">${entry.pos}</span>`;
            if (entry.ipa) html += `<span class="ipa">${entry.ipa}</span>`;
            if (entry.audio) {
                html += `<button class="audio-btn" onclick="playAudio('${entry.audio}')">&#9658; Play</button>`;
            }
            if (entry.pos === 'verb' && entry.forms && entry.forms.length > 0) {
                html += `<button class="conjugate-btn" onclick="toggleConjugation('${entryId}', '${entry.word}')">Conjugate</button>`;
            }
            html += `</div>`;

            if (entry.senses) {
                for (const sense of entry.senses) {
                    html += `<div class="sense">`;
                    if (sense.tags) {
                        html += `<span class="pos">(${sense.tags.join(', ')}) </span>`;
                    }
                    html += `<span class="gloss">${sense.gloss}</span>`;
                    if (sense.examples) {
                        for (const ex of sense.examples) {
                            html += `<div class="example">`;
                            html += `<div class="example-fr">${ex.text}</div>`;
                            if (ex.en) html += `<div class="example-en">${ex.en}</div>`;
                            html += `</div>`;
                        }
                    }
                    html += `</div>`;
                }
            }

            if (entry.etymology) {
                const etymId = 'etym-' + Math.random().toString(36).substr(2, 9);
                const paras = entry.etymology.split('\n');
                const hasMore = paras.length > 1;
                html += `<div class="etymology">`;
                if (hasMore) {
                    // Collapsed view: first para with toggle inline at end
                    html += `<div id="${etymId}" class="etymology-text collapsed"><p>${paras[0]}<span class="etymology-toggle" onclick="toggleEtym('${etymId}')">&#9660;</span></p></div>`;
                    // Expanded view: all paras with toggle inline at end of last
                    html += `<div id="${etymId}-full" class="etymology-text expanded hidden">`;
                    for (let i = 0; i < paras.length; i++) {
                        if (i === paras.length - 1) {
                            html += `<p>${paras[i]}<span class="etymology-toggle" onclick="toggleEtym('${etymId}')">&#9650;</span></p>`;
                        } else {
                            html += `<p>${paras[i]}</p>`;
                        }
                    }
                    html += `</div>`;
                } else {
                    html += `<div class="etymology-text"><p>${entry.etymology}</p></div>`;
                }
                html += `</div>`;
            }

            html += `</div>`;
            return html;
        }

        function doSearch(query) {
            if (!isReady || !query) {
                result.innerHTML = '';
                container.classList.remove('has-results');
                return;
            }

            container.classList.add('has-results');

            // Direct match
            let entries = dict.words[query] ? [...dict.words[query]] : [];
            let viaForm = null;
            let verbEntries = [];

            // Always check conjugated forms (even if direct match exists)
            if (formIndex) {
                const formMatch = findForm(query);
                const infinitives = formMatch ? formIndex[formMatch] : null;
                if (infinitives && infinitives.length > 0) {
                    viaForm = formMatch;
                    // Get verb entries for all matching infinitives
                    for (const inf of infinitives) {
                        if (dict.words[inf]) {
                            verbEntries.push(...dict.words[inf]);
                        }
                    }
                    // Sort: present tense forms first
                    verbEntries.sort((a, b) => {
                        const aForm = a.forms?.find(f => f.form?.toLowerCase() === viaForm);
                        const bForm = b.forms?.find(f => f.form?.toLowerCase() === viaForm);
                        const aPresent = aForm?.tags?.includes('present') ? 0 : 1;
                        const bPresent = bForm?.tags?.includes('present') ? 0 : 1;
                        return aPresent - bPresent;
                    });
                }
            }

            // Combine: show conjugation note + verb entries first, then direct matches
            const allEntries = [...verbEntries, ...entries];

            if (allEntries.length > 0) {
                let html = '';
                if (viaForm && verbEntries.length > 0) {
                    const audioUrl = formAudio ? formAudio[viaForm] : null;
                    const audioBtn = audioUrl ? ` <button class="audio-btn" onclick="playAudio('${audioUrl}')">&#9658;</button>` : '';
                    // Build infinitive list with form tags (already sorted by present first)
                    const infList = verbEntries.map(e => e.word).filter((v,i,a) => a.indexOf(v) === i).map(inf => {
                        // Find verb entry with forms for this infinitive
                        const entry = verbEntries.find(e => e.word === inf && e.forms);
                        if (entry) {
                            const formData = entry.forms.find(f => f.form && f.form.toLowerCase() === viaForm);
                            if (formData && formData.tags) {
                                const tags = formData.tags.filter(t => !['indicative', 'subjunctive', 'conditional', 'imperative'].includes(t));
                                return `${inf} (${tags.join(' ')})`;
                            }
                        }
                        return inf;
                    }).join(', ');
                    html += `<div class="conjugation-note">${viaForm}${audioBtn} → ${infList}</div>`;
                }
                html += allEntries.map(renderEntry).join('');
                result.innerHTML = html;
            } else {
                result.innerHTML = `<div class="no-results">No results for "${query}"</div>`;
            }
        }

        function playAudio(url) {
            new Audio(url).play();
        }

        function toggleEtym(id) {
            const short = document.getElementById(id);
            const full = document.getElementById(id + '-full');
            if (full.classList.contains('hidden')) {
                short.classList.add('hidden');
                full.classList.remove('hidden');
            } else {
                short.classList.remove('hidden');
                full.classList.add('hidden');
            }
        }

        // Conjugation tables
        function toggleConjugation(entryId, word) {
            const entry = document.getElementById(entryId);
            const existing = entry.querySelector('.conjugation-tables');
            if (existing) {
                existing.remove();
                return;
            }

            // Find verb entry with forms
            const entries = dict.words[word];
            const verbEntry = entries?.find(e => e.pos === 'verb' && e.forms);
            if (!verbEntry) return;

            const tables = buildConjugationTables(verbEntry);
            // Insert after header
            const header = entry.querySelector('.entry-header');
            header.insertAdjacentHTML('afterend', tables);
        }

        function buildConjugationTables(entry) {
            const forms = entry.forms;
            const word = entry.word;
            const persons = ['je', 'tu', 'il/elle', 'nous', 'vous', 'ils/elles'];
            const personTags = [
                ['first-person', 'singular'],
                ['second-person', 'singular'],
                ['third-person', 'singular'],
                ['first-person', 'plural'],
                ['second-person', 'plural'],
                ['third-person', 'plural']
            ];

            // Generate naive regular forms for comparison
            function getNaiveForm(tenseKey, personIdx) {
                if (!word.endsWith('er') && !word.endsWith('ir') && !word.endsWith('re')) return null;

                let stem;
                const endings = {
                    er: {
                        pres: ['e', 'es', 'e', 'ons', 'ez', 'ent'],
                        imp: ['ais', 'ais', 'ait', 'ions', 'iez', 'aient'],
                        fut: ['erai', 'eras', 'era', 'erons', 'erez', 'eront'],
                        cond: ['erais', 'erais', 'erait', 'erions', 'eriez', 'eraient'],
                        subj: ['e', 'es', 'e', 'ions', 'iez', 'ent'],
                        psim: ['ai', 'as', 'a', 'âmes', 'âtes', 'èrent'],
                        simp: ['asse', 'asses', 'ât', 'assions', 'assiez', 'assent'],
                    },
                    ir: {
                        pres: ['is', 'is', 'it', 'issons', 'issez', 'issent'],
                        imp: ['issais', 'issais', 'issait', 'issions', 'issiez', 'issaient'],
                        fut: ['irai', 'iras', 'ira', 'irons', 'irez', 'iront'],
                        cond: ['irais', 'irais', 'irait', 'irions', 'iriez', 'iraient'],
                        subj: ['isse', 'isses', 'isse', 'issions', 'issiez', 'issent'],
                        psim: ['is', 'is', 'it', 'îmes', 'îtes', 'irent'],
                        simp: ['isse', 'isses', 'ît', 'issions', 'issiez', 'issent'],
                    },
                    re: {
                        pres: ['s', 's', '', 'ons', 'ez', 'ent'],
                        imp: ['ais', 'ais', 'ait', 'ions', 'iez', 'aient'],
                        fut: ['rai', 'ras', 'ra', 'rons', 'rez', 'ront'],
                        cond: ['rais', 'rais', 'rait', 'rions', 'riez', 'raient'],
                        subj: ['e', 'es', 'e', 'ions', 'iez', 'ent'],
                        psim: ['is', 'is', 'it', 'îmes', 'îtes', 'irent'],
                        simp: ['isse', 'isses', 'ît', 'issions', 'issiez', 'issent'],
                    }
                };

                let type, endingSet;
                if (word.endsWith('er')) { type = 'er'; stem = word.slice(0, -2); endingSet = endings.er; }
                else if (word.endsWith('ir')) { type = 'ir'; stem = word.slice(0, -2); endingSet = endings.ir; }
                else if (word.endsWith('re')) { type = 're'; stem = word.slice(0, -2); endingSet = endings.re; }
                else return null;

                if (!endingSet[tenseKey]) return null;
                return stem + endingSet[tenseKey][personIdx];
            }

            // Helper to find form by tags
            function getForm(requiredTags, personIdx) {
                const [person, number] = personTags[personIdx];
                const match = forms.find(f => {
                    const tags = f.tags || [];
                    return requiredTags.every(t => tags.includes(t)) &&
                           tags.includes(person) && tags.includes(number);
                });
                return match ? match.form : '—';
            }

            // Get participles
            const presentPart = forms.find(f => f.tags?.includes('participle') && f.tags?.includes('present'));
            const pastPart = forms.find(f => f.tags?.includes('participle') && f.tags?.includes('past'));

            // Check if form is irregular by comparing to naive regular form
            function isFormIrregular(form, tenseKey, personIdx) {
                if (form === '—') return false;
                const naive = getNaiveForm(tenseKey, personIdx);
                if (!naive) return false; // Can't determine, don't highlight
                return form.toLowerCase() !== naive.toLowerCase();
            }

            // Table 1: Main tenses
            const mainTenses = [
                { tags: ['indicative', 'present'], name: 'Prés', key: 'pres' },
                { tags: ['indicative', 'imperfect'], name: 'Imp', key: 'imp' },
                { tags: ['indicative', 'future'], name: 'Fut', key: 'fut' },
                { tags: ['conditional'], name: 'Cond', key: 'cond' },
                { tags: ['subjunctive', 'present'], name: 'Subj', key: 'subj' },
            ];

            let html = '<div class="conjugation-tables">';
            html += '<table>';
            html += '<tr>';
            html += `<th class="inf-cell">${entry.word}</th>`;
            for (const t of mainTenses) {
                html += `<th>${t.name}</th>`;
            }
            html += '</tr>';

            for (let i = 0; i < 6; i++) {
                const zebra = i % 2 === 0 ? ' class="zebra"' : '';
                html += `<tr${zebra}>`;
                html += `<td class="person-label">${persons[i]}</td>`;
                for (const t of mainTenses) {
                    const form = getForm(t.tags, i);
                    const cls = isFormIrregular(form, t.key, i) ? ' class="irregular"' : '';
                    html += `<td${cls}>${form}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';

            // Table 2: Extra tenses
            const extraTenses = [
                { tags: ['indicative', 'historic', 'past'], name: 'P.Sim', key: 'psim' },
                { tags: ['subjunctive', 'imperfect'], name: 'S.Imp', key: 'simp' },
            ];

            // Get imperative forms (only tu, nous, vous)
            const imperForms = [
                forms.find(f => f.tags?.includes('imperative') && f.tags?.includes('second-person') && f.tags?.includes('singular')),
                forms.find(f => f.tags?.includes('imperative') && f.tags?.includes('first-person') && f.tags?.includes('plural')),
                forms.find(f => f.tags?.includes('imperative') && f.tags?.includes('second-person') && f.tags?.includes('plural')),
            ];

            // Generate passé composé (auxiliary + past participle)
            const pp = pastPart?.form || '—';
            const usesEtre = entry.aux === 'être';
            let passeCompose;
            if (usesEtre) {
                const etreForms = ['suis', 'es', 'est', 'sommes', 'êtes', 'sont'];
                const agreements = ['(e)', '(e)', '(e)', '(e)s', '(e)(s)', '(e)s'];
                passeCompose = etreForms.map((aux, i) => `${aux} ${pp}${agreements[i]}`);
            } else {
                const avoirForms = ['ai', 'as', 'a', 'avons', 'avez', 'ont'];
                passeCompose = avoirForms.map(aux => `${aux} ${pp}`);
            }

            // Check if past participle is irregular (compare to regular -é/-i/-u)
            function isPPIrregular() {
                if (!pp || pp === '—') return false;
                if (word.endsWith('er')) return pp !== word.slice(0, -2) + 'é';
                if (word.endsWith('ir')) return pp !== word.slice(0, -2) + 'i';
                if (word.endsWith('re')) return pp !== word.slice(0, -2) + 'u';
                return false;
            }

            // Check if present participle is irregular
            function isPresentPartIrregular() {
                if (!presentPart?.form) return false;
                const stem = word.endsWith('er') ? word.slice(0, -2) :
                            word.endsWith('ir') ? word.slice(0, -2) + 'iss' :
                            word.endsWith('re') ? word.slice(0, -2) : null;
                if (!stem) return false;
                return presentPart.form !== stem + 'ant';
            }

            // Check if imperative is irregular (compare against actual present)
            // Philosophy: if imperative matches actual present, don't highlight
            // (since you already learned the present form)
            function isImperIrregular(imperForm, personIdx) {
                if (!imperForm || imperForm === '—') return false;
                // Get actual present form from database
                const actualPres = getForm(['indicative', 'present'], personIdx);
                if (actualPres === '—') return false;
                // For -er verbs, imperative tu drops the 's' (parle vs parles)
                let expected = actualPres;
                if (word.endsWith('er') && personIdx === 1 && actualPres.endsWith('s')) {
                    expected = actualPres.slice(0, -1);
                }
                return imperForm.toLowerCase() !== expected.toLowerCase();
            }

            html += '<table>';
            html += '<tr>';
            const ppCls = isPresentPartIrregular() ? ' class="irregular"' : '';
            html += `<th class="inf-cell"${ppCls}>${presentPart?.form || '—'}</th>`;
            html += `<th>P.Comp</th>`;
            for (const t of extraTenses) {
                html += `<th>${t.name}</th>`;
            }
            html += `<th>Impér</th>`;
            html += '</tr>';

            const imperPersonIdx = [1, 3, 4]; // tu, nous, vous
            const ppIrr = isPPIrregular();
            for (let i = 0; i < 6; i++) {
                const zebra = i % 2 === 0 ? ' class="zebra"' : '';
                html += `<tr${zebra}>`;
                html += `<td class="person-label">${persons[i]}</td>`;
                // Passé composé - only highlight the past participle part, not auxiliary
                if (usesEtre || ppIrr) {
                    // Split into aux + pp, only highlight pp
                    const pcParts = passeCompose[i].split(' ');
                    const aux = pcParts[0];
                    const ppPart = pcParts.slice(1).join(' ');
                    html += `<td>${aux} <span class="irregular">${ppPart}</span></td>`;
                } else {
                    html += `<td>${passeCompose[i]}</td>`;
                }
                for (const t of extraTenses) {
                    const form = getForm(t.tags, i);
                    const cls = isFormIrregular(form, t.key, i) ? ' class="irregular"' : '';
                    html += `<td${cls}>${form}</td>`;
                }
                // Imperative only for tu (1), nous (3), vous (4)
                // Only highlight the verb, not the "!"
                const imperIdx = imperPersonIdx.indexOf(i);
                const imperFormRaw = imperIdx >= 0 && imperForms[imperIdx]?.form ? imperForms[imperIdx].form : null;
                if (imperFormRaw) {
                    const isIrr = isImperIrregular(imperFormRaw, imperPersonIdx[imperIdx]);
                    if (isIrr) {
                        html += `<td><span class="irregular">${imperFormRaw}</span> !</td>`;
                    } else {
                        html += `<td>${imperFormRaw} !</td>`;
                    }
                } else {
                    html += `<td>—</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';

            html += '</div>';
            return html;
        }

        // Remove accents for matching
        function normalize(str) {
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
        }

        // Autocomplete
        function getSuggestions(query) {
            if (!query || !isReady) return [];
            const q = normalize(query);

            // Dictionary words (infinitives, nouns, etc.)
            const dictStarts = wordList.filter(w => normalize(w).startsWith(q));
            const dictContains = wordList.filter(w => !normalize(w).startsWith(q) && normalize(w).includes(q));

            // Conjugated forms
            const formKeys = formIndex ? Object.keys(formIndex) : [];
            const formStarts = formKeys.filter(w => normalize(w).startsWith(q) && !dict.words[w]);

            // Combine: dict words first (by frequency), then forms
            return [...dictStarts, ...formStarts, ...dictContains].slice(0, 8);
        }

        function showSuggestions(matches) {
            if (matches.length === 0) {
                hideSuggestions();
                return;
            }
            suggestions.innerHTML = matches.map((word, i) => {
                const entries = dict.words[word];
                let label = '';
                if (entries) {
                    label = `<span class="pos">${entries[0]?.pos || ''}</span>`;
                } else if (formIndex && formIndex[word]) {
                    label = `<span class="pos">→ ${formIndex[word].join(', ')}</span>`;
                }
                return `<div class="suggestion${i === selectedIdx ? ' selected' : ''}" data-word="${word}">
                    ${word}${label}
                </div>`;
            }).join('');
            suggestions.classList.add('visible');
        }

        function hideSuggestions() {
            suggestions.classList.remove('visible');
            selectedIdx = -1;
        }

        function selectWord(word) {
            search.value = word;
            hideSuggestions();
            doSearch(word);
        }

        // Find word in dict (accent-insensitive)
        function findWord(query) {
            // Exact match first
            if (dict.words[query]) return query;
            // Normalized match
            const q = normalize(query);
            for (const word of wordList) {
                if (normalize(word) === q) return word;
            }
            return null;
        }

        // Find in form index (accent-insensitive)
        function findForm(query) {
            if (formIndex[query]) return query;
            const q = normalize(query);
            for (const form of Object.keys(formIndex)) {
                if (normalize(form) === q) return form;
            }
            return null;
        }

        function updateSuggestions(query) {
            if (!query) {
                hideSuggestions();
                result.innerHTML = '';
                container.classList.remove('has-results');
                return;
            }

            // Always show suggestions while typing
            const matches = getSuggestions(query);
            showSuggestions(matches);

            // Also show result if exact match exists
            const match = findWord(query) || findForm(query);
            if (match) {
                doSearch(match);
            } else {
                result.innerHTML = '';
                container.classList.remove('has-results');
            }
        }

        // Event handlers
        search.addEventListener('input', () => {
            selectedIdx = -1;
            updateSuggestions(search.value.trim().toLowerCase());
        });

        search.addEventListener('keydown', (e) => {
            const items = suggestions.querySelectorAll('.suggestion');
            if (!suggestions.classList.contains('visible')) {
                if (e.key === 'Enter') {
                    const q = search.value.trim().toLowerCase();
                    if (q) doSearch(q);
                }
                return;
            }

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIdx = Math.min(selectedIdx + 1, items.length - 1);
                showSuggestions(getSuggestions(search.value.trim().toLowerCase()));
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIdx = Math.max(selectedIdx - 1, -1);
                showSuggestions(getSuggestions(search.value.trim().toLowerCase()));
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIdx >= 0) {
                    selectWord(items[selectedIdx].dataset.word);
                } else {
                    const q = search.value.trim().toLowerCase();
                    if (q) doSearch(q);
                    hideSuggestions();
                }
            } else if (e.key === 'Escape') {
                hideSuggestions();
            }
        });

        suggestions.addEventListener('click', (e) => {
            const item = e.target.closest('.suggestion');
            if (item) selectWord(item.dataset.word);
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                hideSuggestions();
            }
        });

        // Start loading immediately
        loadDictionary();
    </script>
</body>
</html>
