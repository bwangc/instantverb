<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instantverb</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .search-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 25vh;
            transition: margin-top 0.3s ease;
            width: 100%;
            max-width: 600px;
        }

        .search-container.has-results {
            margin-top: 40px;
        }

        h1 {
            font-weight: 300;
            font-size: 3.5rem;
            margin-bottom: 30px;
            color: #a5b4fc;
            letter-spacing: -1px;
        }

        .input-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
        }

        #search {
            font-size: 1.1rem;
            padding: 14px 24px;
            border: 1px solid #3a3a5e;
            border-radius: 24px;
            background: #252542;
            color: #eee;
            width: 100%;
            outline: none;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #search:hover {
            background: #2a2a4a;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        #search:focus {
            background: #2a2a4a;
            border-color: #a5b4fc;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        #search::placeholder { color: #666; }

        #search.has-suggestions {
            border-radius: 24px 24px 0 0;
        }

        .suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #252542;
            border: 1px solid #3a3a5e;
            border-top: none;
            border-radius: 0 0 16px 16px;
            max-height: 240px;
            overflow-y: auto;
            display: none;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .suggestions.visible { display: block; }

        .suggestion {
            padding: 10px 24px;
            cursor: pointer;
            transition: background 0.1s;
        }

        .suggestion:hover, .suggestion.selected {
            background: #3a3a5e;
        }

        .suggestion:last-child {
            border-radius: 0 0 16px 16px;
        }

        .suggestion .pos {
            margin-left: 8px;
            font-size: 0.85rem;
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            margin-top: 8px;
        }

        .status:empty {
            display: none;
        }

        .status.ready { color: #4ade80; }
        .status.loading { color: #a5b4fc; }

        #result {
            margin-top: 20px;
            width: 100%;
            max-width: 700px;
        }

        .entry {
            background: #252542;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .entry-header {
            display: flex;
            align-items: baseline;
            gap: 12px;
            margin-bottom: 12px;
        }

        .word {
            font-size: 1.5rem;
            color: #a5b4fc;
        }

        .pos {
            font-size: 0.9rem;
            color: #888;
            font-style: italic;
        }

        .ipa {
            font-size: 0.9rem;
            color: #888;
        }

        .sense {
            margin: 12px 0;
            padding-left: 16px;
            border-left: 2px solid #3a3a5e;
        }

        .gloss {
            color: #eee;
            margin-bottom: 6px;
        }

        .example {
            font-size: 0.9rem;
            color: #aaa;
            margin: 4px 0;
        }

        .example-fr { font-style: italic; }
        .example-en { color: #888; }

        .audio-btn {
            background: none;
            border: 1px solid #3a3a5e;
            color: #a5b4fc;
            padding: 4px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .audio-btn:hover { background: #3a3a5e; }

        .conjugate-btn {
            background: none;
            border: 1px solid #3a3a5e;
            color: #a5b4fc;
            padding: 4px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .conjugate-btn:hover { background: #3a3a5e; }

        .conjugation-tables {
            display: inline-flex;
            flex-direction: column;
        }

        .conjugation-tables table {
            border-collapse: collapse;
            font-size: 14px;
        }

        .conjugation-tables table:first-child {
            margin-bottom: 16px;
        }

        .conjugation-tables th, .conjugation-tables td {
            padding: 8px 12px;
            text-align: left;
        }

        .conjugation-tables th {
            color: #a5b4fc;
            border-bottom: 1px solid #a5b4fc;
        }

        .conjugation-tables .inf-cell {
            font-style: italic;
            border-bottom: none;
        }

        .conjugation-tables tr.zebra {
            background: rgba(255,255,255,0.03);
        }

        .conjugation-tables .person-label {
            color: #a5b4fc;
        }

        .conjugation-tables .irregular {
            color: #a5b4fc;
        }

        .etymology {
            font-size: 0.85rem;
            color: #888;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #3a3a5e;
        }

        .etymology-text p {
            margin: 0 0 8px 0;
        }

        .etymology-text p:last-child {
            margin-bottom: 0;
        }

        .etymology-extra {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
            max-height: 2000px;
            margin-top: 8px;
        }

        .etymology-extra.hidden {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .etymology-toggle {
            color: #666;
            cursor: pointer;
            font-size: 0.7rem;
            margin-left: 8px;
            transition: color 0.15s;
        }

        .etymology-toggle:hover {
            color: #a5b4fc;
        }

        .no-results {
            color: #888;
            text-align: center;
            padding: 40px;
        }

        .conjugation-note {
            color: #a5b4fc;
            font-size: 0.9rem;
            margin-bottom: 16px;
            padding: 8px 16px;
            background: rgba(165, 180, 252, 0.1);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="search-container" id="container">
        <h1>Instantverb</h1>
        <div class="input-wrapper">
            <input type="text" id="search" placeholder="Search French words..." autocomplete="off" autofocus>
            <div class="suggestions" id="suggestions"></div>
        </div>
        <div class="status loading" id="status">Loading dictionary...</div>
    </div>

    <div id="result"></div>

    <script>
        let dict = null;
        let formIndex = null;  // conjugated form -> infinitive(s)
        let formAudio = null;  // conjugated form -> audio URL
        let wordList = [];  // Ordered list for autocomplete
        let isReady = false;
        let selectedIdx = -1;

        const search = document.getElementById('search');
        const result = document.getElementById('result');
        const status = document.getElementById('status');
        const container = document.getElementById('container');
        const suggestions = document.getElementById('suggestions');

        // Fetch and decompress gzipped JSON
        async function fetchGzip(url) {
            const res = await fetch(url);
            const ds = new DecompressionStream('gzip');
            const decompressed = res.body.pipeThrough(ds);
            const text = await new Response(decompressed).text();
            return JSON.parse(text);
        }

        // Load dictionary in background
        async function loadDictionary() {
            try {
                // Load all in parallel
                const [dictData, formsData, audioRes] = await Promise.all([
                    fetchGzip('data/fr-dict.json.gz'),
                    fetchGzip('data/fr-forms.json.gz'),
                    fetch('data/fr-form-audio.json')
                ]);
                dict = dictData;
                formIndex = formsData.forms;
                formAudio = await audioRes.json();
                wordList = Object.keys(dict.words);  // Preserves frequency order
                isReady = true;
                status.style.display = 'none';

                // If user already typed something, search now
                if (search.value.trim()) {
                    updateSuggestions(search.value.trim().toLowerCase());
                }
            } catch (e) {
                status.textContent = 'Failed to load dictionary';
                status.className = 'status';
            }
        }

        function renderEntry(entry) {
            const entryId = 'entry-' + Math.random().toString(36).substr(2, 9);
            let html = `<div class="entry" id="${entryId}">`;
            html += `<div class="entry-header">`;
            html += `<span class="word">${entry.word}</span>`;
            html += `<span class="pos">${entry.pos}</span>`;
            if (entry.ipa) html += `<span class="ipa">${entry.ipa}</span>`;
            if (entry.audio) {
                html += `<button class="audio-btn" onclick="playAudio('${entry.audio}')">&#9658; Play</button>`;
            }
            if (entry.pos === 'verb' && entry.forms && entry.forms.length > 0) {
                const escapedWord = entry.word.replace(/'/g, "\\'");
                html += `<button class="conjugate-btn" onclick="toggleConjugation('${entryId}', '${escapedWord}')">Conjugate</button>`;
            }
            html += `</div>`;

            if (entry.senses) {
                for (const sense of entry.senses) {
                    html += `<div class="sense">`;
                    if (sense.tags) {
                        html += `<span class="pos">(${sense.tags.join(', ')}) </span>`;
                    }
                    html += `<span class="gloss">${sense.gloss}</span>`;
                    if (sense.examples) {
                        for (const ex of sense.examples) {
                            html += `<div class="example">`;
                            html += `<div class="example-fr">${ex.text}</div>`;
                            if (ex.en) html += `<div class="example-en">${ex.en}</div>`;
                            html += `</div>`;
                        }
                    }
                    html += `</div>`;
                }
            }

            if (entry.etymology) {
                const etymId = 'etym-' + Math.random().toString(36).substr(2, 9);
                const paras = entry.etymology.split('\n');
                const hasMore = paras.length > 1;
                html += `<div class="etymology">`;
                if (hasMore) {
                    // First paragraph always visible with collapse button (shown when collapsed)
                    html += `<div class="etymology-text"><p>${paras[0]}<span id="${etymId}-btn" class="etymology-toggle" onclick="toggleEtym('${etymId}')">&#9660;</span></p></div>`;
                    // Additional paragraphs (animated)
                    html += `<div id="${etymId}" class="etymology-text etymology-extra hidden">`;
                    for (let i = 1; i < paras.length - 1; i++) {
                        html += `<p>${paras[i]}</p>`;
                    }
                    // Last paragraph with expand button (shown when expanded)
                    html += `<p>${paras[paras.length - 1]}<span id="${etymId}-btn2" class="etymology-toggle" style="display:none" onclick="toggleEtym('${etymId}')">&#9650;</span></p>`;
                    html += `</div>`;
                } else {
                    html += `<div class="etymology-text"><p>${entry.etymology}</p></div>`;
                }
                html += `</div>`;
            }

            html += `</div>`;
            return html;
        }

        function doSearch(query) {
            if (!isReady || !query) {
                result.innerHTML = '';
                container.classList.remove('has-results');
                return;
            }

            container.classList.add('has-results');

            // Find ALL matching words (accent-insensitive)
            const matchingWords = findAllWords(query);
            let entries = [];
            for (const dictKey of matchingWords) {
                if (dict.words[dictKey]) {
                    for (const entry of dict.words[dictKey]) {
                        entries.push({...entry, _key: dictKey});
                    }
                }
            }
            // Sort: exact key matches first (same accents), then lowercase before uppercase
            const queryLower = query.toLowerCase();
            entries.sort((a, b) => {
                // Prefer entries whose dictionary key exactly matches query (same accents)
                const aExact = a._key === queryLower ? 0 : 1;
                const bExact = b._key === queryLower ? 0 : 1;
                if (aExact !== bExact) return aExact - bExact;
                const aLower = a.word[0] === a.word[0].toLowerCase() ? 0 : 1;
                const bLower = b.word[0] === b.word[0].toLowerCase() ? 0 : 1;
                return aLower - bLower;
            });

            let verbEntries = [];
            let formNotes = [];  // Array of {form, audioUrl, infList}

            // Check ALL matching conjugated forms
            if (formIndex) {
                const matchingForms = findAllForms(query);
                for (const formMatch of matchingForms) {
                    const infinitives = formIndex[formMatch];
                    if (infinitives && infinitives.length > 0) {
                        const formVerbEntries = [];
                        for (const inf of infinitives) {
                            if (dict.words[inf]) {
                                formVerbEntries.push(...dict.words[inf]);
                            }
                        }
                        // Sort: present tense forms first
                        formVerbEntries.sort((a, b) => {
                            const aForm = a.forms?.find(f => f.form?.toLowerCase() === formMatch);
                            const bForm = b.forms?.find(f => f.form?.toLowerCase() === formMatch);
                            const aPresent = aForm?.tags?.includes('present') ? 0 : 1;
                            const bPresent = bForm?.tags?.includes('present') ? 0 : 1;
                            return aPresent - bPresent;
                        });
                        verbEntries.push(...formVerbEntries);

                        // Build note for this form
                        const audioUrl = formAudio ? formAudio[formMatch] : null;
                        const infList = formVerbEntries.map(e => e.word).filter((v,i,a) => a.indexOf(v) === i).map(inf => {
                            const entry = formVerbEntries.find(e => e.word === inf && e.forms);
                            if (entry) {
                                const formData = entry.forms.find(f => f.form && f.form.toLowerCase() === formMatch);
                                if (formData && formData.tags) {
                                    const tags = formData.tags.filter(t => !['indicative', 'subjunctive', 'conditional', 'imperative'].includes(t));
                                    return `${inf} (${tags.join(' ')})`;
                                }
                            }
                            return inf;
                        }).join(', ');
                        formNotes.push({ form: formMatch, audioUrl, infList });
                    }
                }
            }

            // Combine all entries, prioritizing exact matches
            const seenWords = new Set();
            const allEntries = [];

            // First: direct exact matches (dictionary key equals query)
            for (const e of entries) {
                if (e._key === queryLower) {
                    allEntries.push(e);
                    seenWords.add(e.word + e.pos);
                }
            }

            // Second: verb form exact matches (form equals query)
            for (const note of formNotes) {
                if (note.form === queryLower) {
                    for (const e of verbEntries) {
                        const key = e.word + e.pos;
                        if (!seenWords.has(key)) {
                            allEntries.push(e);
                            seenWords.add(key);
                        }
                    }
                }
            }

            // Third: direct non-exact matches (normalized match)
            for (const e of entries) {
                const key = e.word + e.pos;
                if (!seenWords.has(key)) {
                    allEntries.push(e);
                    seenWords.add(key);
                }
            }

            // Fourth: remaining verb form matches
            for (const e of verbEntries) {
                const key = e.word + e.pos;
                if (!seenWords.has(key)) {
                    allEntries.push(e);
                    seenWords.add(key);
                }
            }

            if (allEntries.length > 0) {
                let html = '';
                // Show conjugation notes for all matching forms
                for (const note of formNotes) {
                    const audioBtn = note.audioUrl ? ` <button class="audio-btn" onclick="playAudio('${note.audioUrl}')">&#9658;</button>` : '';
                    html += `<div class="conjugation-note">${note.form}${audioBtn} → ${note.infList}</div>`;
                }
                html += allEntries.map(renderEntry).join('');
                result.innerHTML = html;
            } else {
                result.innerHTML = `<div class="no-results">No results for "${query}"</div>`;
            }
        }

        function playAudio(url) {
            new Audio(url).play();
        }

        function toggleEtym(id) {
            const extra = document.getElementById(id);
            const btn1 = document.getElementById(id + '-btn');
            const btn2 = document.getElementById(id + '-btn2');
            if (extra.classList.contains('hidden')) {
                extra.classList.remove('hidden');
                btn1.style.display = 'none';
                btn2.style.display = '';
            } else {
                extra.classList.add('hidden');
                btn1.style.display = '';
                btn2.style.display = 'none';
            }
        }

        // Conjugation tables
        function toggleConjugation(entryId, word) {
            const entry = document.getElementById(entryId);
            const existing = entry.querySelector('.conjugation-tables');
            if (existing) {
                existing.remove();
                return;
            }

            // Find verb entry with forms
            const entries = dict.words[word];
            const verbEntry = entries?.find(e => e.pos === 'verb' && e.forms);
            if (!verbEntry) return;

            const tables = buildConjugationTables(verbEntry);
            const header = entry.querySelector('.entry-header');
            header.insertAdjacentHTML('afterend', tables);
        }

        function buildConjugationTables(entry) {
            const forms = entry.forms;
            const word = entry.word;
            const persons = ['je', 'tu', 'il/elle', 'nous', 'vous', 'ils/elles'];
            const personTags = [
                ['first-person', 'singular'],
                ['second-person', 'singular'],
                ['third-person', 'singular'],
                ['first-person', 'plural'],
                ['second-person', 'plural'],
                ['third-person', 'plural']
            ];

            // Generate naive regular forms for comparison
            function getNaiveForm(tenseKey, personIdx) {
                if (!word.endsWith('er') && !word.endsWith('ir') && !word.endsWith('re')) return null;

                let stem;
                const endings = {
                    er: {
                        pres: ['e', 'es', 'e', 'ons', 'ez', 'ent'],
                        imp: ['ais', 'ais', 'ait', 'ions', 'iez', 'aient'],
                        fut: ['erai', 'eras', 'era', 'erons', 'erez', 'eront'],
                        cond: ['erais', 'erais', 'erait', 'erions', 'eriez', 'eraient'],
                        subj: ['e', 'es', 'e', 'ions', 'iez', 'ent'],
                        psim: ['ai', 'as', 'a', 'âmes', 'âtes', 'èrent'],
                        simp: ['asse', 'asses', 'ât', 'assions', 'assiez', 'assent'],
                    },
                    ir: {
                        pres: ['is', 'is', 'it', 'issons', 'issez', 'issent'],
                        imp: ['issais', 'issais', 'issait', 'issions', 'issiez', 'issaient'],
                        fut: ['irai', 'iras', 'ira', 'irons', 'irez', 'iront'],
                        cond: ['irais', 'irais', 'irait', 'irions', 'iriez', 'iraient'],
                        subj: ['isse', 'isses', 'isse', 'issions', 'issiez', 'issent'],
                        psim: ['is', 'is', 'it', 'îmes', 'îtes', 'irent'],
                        simp: ['isse', 'isses', 'ît', 'issions', 'issiez', 'issent'],
                    },
                    re: {
                        pres: ['s', 's', '', 'ons', 'ez', 'ent'],
                        imp: ['ais', 'ais', 'ait', 'ions', 'iez', 'aient'],
                        fut: ['rai', 'ras', 'ra', 'rons', 'rez', 'ront'],
                        cond: ['rais', 'rais', 'rait', 'rions', 'riez', 'raient'],
                        subj: ['e', 'es', 'e', 'ions', 'iez', 'ent'],
                        psim: ['is', 'is', 'it', 'îmes', 'îtes', 'irent'],
                        simp: ['isse', 'isses', 'ît', 'issions', 'issiez', 'issent'],
                    }
                };

                let type, endingSet;
                if (word.endsWith('er')) { type = 'er'; stem = word.slice(0, -2); endingSet = endings.er; }
                else if (word.endsWith('ir')) { type = 'ir'; stem = word.slice(0, -2); endingSet = endings.ir; }
                else if (word.endsWith('re')) { type = 're'; stem = word.slice(0, -2); endingSet = endings.re; }
                else return null;

                if (!endingSet[tenseKey]) return null;
                return stem + endingSet[tenseKey][personIdx];
            }

            // Helper to find form by tags
            function getForm(requiredTags, personIdx) {
                const [person, number] = personTags[personIdx];
                const match = forms.find(f => {
                    const tags = f.tags || [];
                    return requiredTags.every(t => tags.includes(t)) &&
                           tags.includes(person) && tags.includes(number);
                });
                // Treat "-" as missing (impersonal verbs like falloir)
                if (match && match.form === '-') return '—';
                return match ? match.form : '—';
            }

            // Get participles
            const presentPart = forms.find(f => f.tags?.includes('participle') && f.tags?.includes('present'));
            const pastPart = forms.find(f => f.tags?.includes('participle') && f.tags?.includes('past'));

            // Check if verb is impersonal (only 3rd person singular exists)
            const isImpersonal = forms.some(f => f.form === '-');

            // Check if form is irregular by comparing to naive regular form
            function isFormIrregular(form, tenseKey, personIdx) {
                if (form === '—' || form === '-') return false;
                const naive = getNaiveForm(tenseKey, personIdx);
                if (!naive) return false; // Can't determine, don't highlight
                return form.toLowerCase() !== naive.toLowerCase();
            }

            // Check if this is an s'en verb
            const isSenVerb = word.startsWith("s'en ");

            // Render form with proper irregular highlighting
            function renderForm(form, isIrregular) {
                if (form === '—') return form;
                if (!isIrregular) return form;

                // For s'en verbs, only highlight the verb part (last word)
                if (isSenVerb) {
                    const parts = form.split(' ');
                    if (parts.length > 1) {
                        const verbPart = parts.pop();
                        return parts.join(' ') + ' <span class="irregular">' + verbPart + '</span>';
                    }
                }
                return '<span class="irregular">' + form + '</span>';
            }

            // Table 1: Main tenses
            const mainTenses = [
                { tags: ['indicative', 'present'], name: 'Prés', key: 'pres' },
                { tags: ['indicative', 'imperfect'], name: 'Imp', key: 'imp' },
                { tags: ['indicative', 'future'], name: 'Fut', key: 'fut' },
                { tags: ['conditional'], name: 'Cond', key: 'cond' },
                { tags: ['subjunctive', 'present'], name: 'Subj', key: 'subj' },
            ];

            let html = '<div class="conjugation-tables">';
            html += '<table>';
            html += '<tr>';
            html += `<th class="inf-cell">${entry.word}</th>`;
            for (const t of mainTenses) {
                html += `<th>${t.name}</th>`;
            }
            html += '</tr>';

            for (let i = 0; i < 6; i++) {
                const zebra = i % 2 === 0 ? ' class="zebra"' : '';
                html += `<tr${zebra}>`;
                html += `<td class="person-label">${persons[i]}</td>`;
                for (const t of mainTenses) {
                    const form = getForm(t.tags, i);
                    const isIrr = isFormIrregular(form, t.key, i);
                    html += `<td>${renderForm(form, isIrr)}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';

            // Table 2: Extra tenses
            const extraTenses = [
                { tags: ['indicative', 'historic', 'past'], name: 'P.Sim', key: 'psim' },
                { tags: ['subjunctive', 'imperfect'], name: 'S.Imp', key: 'simp' },
            ];

            // Get imperative forms (only tu, nous, vous)
            const imperForms = [
                forms.find(f => f.tags?.includes('imperative') && f.tags?.includes('second-person') && f.tags?.includes('singular')),
                forms.find(f => f.tags?.includes('imperative') && f.tags?.includes('first-person') && f.tags?.includes('plural')),
                forms.find(f => f.tags?.includes('imperative') && f.tags?.includes('second-person') && f.tags?.includes('plural')),
            ];

            // Generate passé composé (auxiliary + past participle)
            const pp = pastPart?.form || '—';
            // s'en verbs and other pronominal verbs use être
            const usesEtre = entry.aux === 'être' || isSenVerb;
            let passeCompose;
            if (isImpersonal) {
                // Impersonal verbs only have 3rd person singular
                passeCompose = ['—', '—', `a ${pp}`, '—', '—', '—'];
                if (isSenVerb) {
                    passeCompose[2] = `s'en est ${pp}`;
                }
            } else if (usesEtre) {
                const etreForms = ['suis', 'es', 'est', 'sommes', 'êtes', 'sont'];
                const agreements = ['(e)', '(e)', '(e)', '(e)s', '(e)(s)', '(e)s'];
                if (isSenVerb) {
                    // s'en verbs need pronominal prefixes
                    const senPrefixes = ["m'en ", "t'en ", "s'en ", "nous en ", "vous en ", "s'en "];
                    passeCompose = etreForms.map((aux, i) => `${senPrefixes[i]}${aux} ${pp}${agreements[i]}`);
                } else {
                    passeCompose = etreForms.map((aux, i) => `${aux} ${pp}${agreements[i]}`);
                }
            } else {
                const avoirForms = ['ai', 'as', 'a', 'avons', 'avez', 'ont'];
                passeCompose = avoirForms.map(aux => `${aux} ${pp}`);
            }

            // Check if past participle is irregular (compare to regular -é/-i/-u)
            function isPPIrregular() {
                if (!pp || pp === '—') return false;
                if (word.endsWith('er')) return pp !== word.slice(0, -2) + 'é';
                if (word.endsWith('ir')) return pp !== word.slice(0, -2) + 'i';
                if (word.endsWith('re')) return pp !== word.slice(0, -2) + 'u';
                return false;
            }

            // Check if present participle is irregular
            function isPresentPartIrregular() {
                if (!presentPart?.form) return false;
                const stem = word.endsWith('er') ? word.slice(0, -2) :
                            word.endsWith('ir') ? word.slice(0, -2) + 'iss' :
                            word.endsWith('re') ? word.slice(0, -2) : null;
                if (!stem) return false;
                return presentPart.form !== stem + 'ant';
            }

            // Check if imperative is irregular (compare against actual present)
            // Philosophy: if imperative matches actual present, don't highlight
            // (since you already learned the present form)
            function isImperIrregular(imperForm, personIdx) {
                if (!imperForm || imperForm === '—') return false;
                // Get actual present form from database
                const actualPres = getForm(['indicative', 'present'], personIdx);
                if (actualPres === '—') return false;
                // For -er verbs, imperative tu drops the 's' (parle vs parles)
                let expected = actualPres;
                if (word.endsWith('er') && personIdx === 1 && actualPres.endsWith('s')) {
                    expected = actualPres.slice(0, -1);
                }
                return imperForm.toLowerCase() !== expected.toLowerCase();
            }

            html += '<table>';
            html += '<tr>';
            const presentPartForm = presentPart?.form || '—';
            const presentPartIrr = isPresentPartIrregular();
            html += `<th class="inf-cell">${renderForm(presentPartForm, presentPartIrr)}</th>`;
            html += `<th>P.Comp</th>`;
            for (const t of extraTenses) {
                html += `<th>${t.name}</th>`;
            }
            html += `<th>Impér</th>`;
            html += '</tr>';

            const imperPersonIdx = [1, 3, 4]; // tu, nous, vous
            const ppIrr = isPPIrregular();
            for (let i = 0; i < 6; i++) {
                const zebra = i % 2 === 0 ? ' class="zebra"' : '';
                html += `<tr${zebra}>`;
                html += `<td class="person-label">${persons[i]}</td>`;
                // Passé composé - only highlight the past participle part, not auxiliary/pronouns
                if (passeCompose[i] === '—') {
                    html += `<td>—</td>`;
                } else if (usesEtre || ppIrr) {
                    // Split and only highlight the last part (past participle with agreement)
                    const pcParts = passeCompose[i].split(' ');
                    const ppPart = pcParts.pop(); // Last part is the past participle
                    const prefix = pcParts.join(' ');
                    html += `<td>${prefix} <span class="irregular">${ppPart}</span></td>`;
                } else {
                    html += `<td>${passeCompose[i]}</td>`;
                }
                for (const t of extraTenses) {
                    const form = getForm(t.tags, i);
                    const isIrr = isFormIrregular(form, t.key, i);
                    html += `<td>${renderForm(form, isIrr)}</td>`;
                }
                // Imperative only for tu (1), nous (3), vous (4)
                // Only highlight the verb, not the "!"
                const imperIdx = imperPersonIdx.indexOf(i);
                let imperFormRaw = imperIdx >= 0 && imperForms[imperIdx]?.form ? imperForms[imperIdx].form : null;
                // Treat "-" as missing (impersonal verbs)
                if (imperFormRaw === '-') imperFormRaw = null;
                if (imperFormRaw) {
                    const isIrr = isImperIrregular(imperFormRaw, imperPersonIdx[imperIdx]);
                    if (isIrr) {
                        html += `<td>${renderForm(imperFormRaw, true)} !</td>`;
                    } else {
                        html += `<td>${imperFormRaw} !</td>`;
                    }
                } else {
                    html += `<td>—</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';

            html += '</div>';
            return html;
        }

        // Remove accents for matching
        function normalize(str) {
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
        }

        // Autocomplete
        function getSuggestions(query) {
            if (!query || !isReady) return [];
            const q = normalize(query);

            // Dictionary words (infinitives, nouns, etc.)
            const dictStarts = wordList.filter(w => normalize(w).startsWith(q));
            const dictContains = wordList.filter(w => !normalize(w).startsWith(q) && normalize(w).includes(q));

            // Conjugated forms
            const formKeys = formIndex ? Object.keys(formIndex) : [];
            const formStarts = formKeys.filter(w => normalize(w).startsWith(q) && !dict.words[w]);

            // Combine: dict words first (by frequency), then forms
            return [...dictStarts, ...formStarts, ...dictContains].slice(0, 8);
        }

        function showSuggestions(matches) {
            if (matches.length === 0) {
                hideSuggestions();
                return;
            }
            suggestions.innerHTML = matches.map((word, i) => {
                const entries = dict.words[word];
                let label = '';
                if (entries) {
                    label = `<span class="pos">${entries[0]?.pos || ''}</span>`;
                } else if (formIndex && formIndex[word]) {
                    label = `<span class="pos">→ ${formIndex[word].join(', ')}</span>`;
                }
                return `<div class="suggestion${i === selectedIdx ? ' selected' : ''}" data-word="${word}">
                    ${word}${label}
                </div>`;
            }).join('');
            suggestions.classList.add('visible');
            search.classList.add('has-suggestions');
        }

        function hideSuggestions() {
            suggestions.classList.remove('visible');
            search.classList.remove('has-suggestions');
            selectedIdx = -1;
        }

        function selectWord(word) {
            search.value = word;
            hideSuggestions();
            doSearch(word);
        }

        // Find ALL words in dict matching query (accent-insensitive)
        function findAllWords(query) {
            const q = normalize(query);
            const matches = [];
            for (const word of wordList) {
                if (normalize(word) === q) matches.push(word);
            }
            return matches;
        }

        // Find ALL forms matching query (accent-insensitive)
        function findAllForms(query) {
            const q = normalize(query);
            const matches = [];
            for (const form of Object.keys(formIndex || {})) {
                if (normalize(form) === q) matches.push(form);
            }
            return matches;
        }

        // Legacy single-match functions (for suggestions hiding logic)
        function findWord(query) {
            const matches = findAllWords(query);
            return matches.length > 0 ? matches[0] : null;
        }

        function findForm(query) {
            const matches = findAllForms(query);
            return matches.length > 0 ? matches[0] : null;
        }

        function updateSuggestions(query) {
            if (!query) {
                hideSuggestions();
                result.innerHTML = '';
                container.classList.remove('has-results');
                return;
            }

            // Check for match (just to know if we should search or show suggestions)
            const match = findWord(query) || findForm(query);
            if (match) {
                hideSuggestions();
                doSearch(query);  // Pass original query, not matched key
            } else {
                // Show suggestions while typing
                const matches = getSuggestions(query);
                showSuggestions(matches);
                result.innerHTML = '';
                container.classList.remove('has-results');
            }
        }

        // Event handlers
        search.addEventListener('input', () => {
            selectedIdx = -1;
            updateSuggestions(search.value.trim().toLowerCase());
        });

        search.addEventListener('keydown', (e) => {
            const items = suggestions.querySelectorAll('.suggestion');
            if (!suggestions.classList.contains('visible')) {
                if (e.key === 'Enter') {
                    const q = search.value.trim().toLowerCase();
                    if (q) doSearch(q);
                }
                return;
            }

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIdx = Math.min(selectedIdx + 1, items.length - 1);
                showSuggestions(getSuggestions(search.value.trim().toLowerCase()));
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIdx = Math.max(selectedIdx - 1, -1);
                showSuggestions(getSuggestions(search.value.trim().toLowerCase()));
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIdx >= 0) {
                    selectWord(items[selectedIdx].dataset.word);
                } else {
                    const q = search.value.trim().toLowerCase();
                    if (q) doSearch(q);
                    hideSuggestions();
                }
            } else if (e.key === 'Escape') {
                hideSuggestions();
            }
        });

        suggestions.addEventListener('click', (e) => {
            const item = e.target.closest('.suggestion');
            if (item) selectWord(item.dataset.word);
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.input-wrapper')) {
                hideSuggestions();
            }
        });

        // Start loading immediately
        loadDictionary();
    </script>
</body>
</html>
